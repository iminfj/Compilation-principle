package com.apollo.SyntaxAnalysis;

import java.io.IOException;
import java.util.*;

import apollo.core.lowlevel.anonymous;
import com.apollo.lexical.LexAttribute;
import com.apollo.lexical.Lexical;

public class Syntax extends lowlevelcache {
	/**
	 * lexical element list
	 * */
	public static Hashtable<Integer, LexAttribute> lexlist = new Hashtable<>();

	/**
	 * terminal symbol
	 * */
	public static HashSet<String> Vt = new HashSet<>();

	/**
	 * nonterminal symbol
	 * */
	public static HashSet<String> Vn = new HashSet<>();

	public HashSet<String> A () {
		HashSet<String> T = new HashSet<>();
		T.addAll(Vn);
		T.addAll(Vt);
		return T;
	}

	public static Hashtable<String, Integer> Asequence = new Hashtable<String, Integer>();
	public static Hashtable<String, Integer> VtSequence = new Hashtable<String, Integer>();
	public static Hashtable<String, Integer> VnSequence = new Hashtable<String, Integer>();

	/**
	 * Production
	 * */
	private final Hashtable<Integer, String> SetP = new Hashtable<>();

	/**
	 * Integer -> Generative expression pointer
	 * String -> nonterminal symbol
	 * Generative expression -> P(X∈Vn)
	 * */
	public static Hashtable<Integer, Production> P = new Hashtable<>();

	/**
	 * Start symbol
	 * */
	private String S;

	/**
	 * 	<p>Store temporary first set</p>
	 * */
	public HashSet<String> getfirst = new HashSet<>();

	/**
	 * <p>Store temporary follow set</p>
	 * */
	public HashSet<String> getfollow = new HashSet<>();

	/**
	 * <p>First set of all Vn</p>
	 * */
	public static Hashtable<String, HashSet<String>> firsts = new Hashtable<>();

	/**
	 * <p>Follow set of all Vn</p>
	 * */
	public static Hashtable<String, HashSet<String>> follows = new Hashtable<>();

	public static ItemFamily Ij = new ItemFamily();

	public Syntax() {
		// pass
	}

	public Hashtable<Integer, Production> LR_P = new Hashtable<Integer, Production>();

	public String[] LR_G = {

			"E' -> E",
			"E -> E + T",	"E -> T",
			"T -> T * F",	"T -> F",
			"F -> ( E )",	"F -> id",
	};

	// ##################################################
	/**
	 * <p>Parsing
	 * @param list <p>The morpheme set generated by the lexical analyzer
	 * */
	public Syntax(Hashtable<Integer, LexAttribute> list) throws IOException {
		lexlist = list;
		
		// Initialization grammar
		loadG();

		// Start symbol
		super.print("start_symbol: {0}", S);

		// Traverse and print all productions
		SetP.forEach((i, p) -> System.out.println("'" + p + "'"));

		// Split production
		SetP.forEach((i, p) -> splitProduction(p));

		try {
			HashSet<String> Vx = new HashSet<String>();
			Vx.addAll(Vt);
			Vx.addAll(Vn);

			// 计算 Vx的 first集，Vx∈Vt, Vx∈Vn
			for (String vx : Vx) {
				first(vx);
			}

			// 计算所有 Vn的 follow集
			for (String vn : Vn) {
				follow(vn);
			}

			// 计算 followMemory集，优化所有 follow集
			optimizeFollow();

			// 计算所有产生式的 select集
//			select(ptoarray());

		} catch (Exception e) {
			e.printStackTrace();
		}


		// Grammar symbol encoding
		super.encGrammarSymbol(new anonymous() {
			public ArrayList<String> retVn(HashSet<String> vn) {
				arrayList_string.addAll(vn);
				return arrayList_string;
			}
		}.retVn(Vn), new anonymous() {
			public ArrayList<String> retVt(HashSet<String> vt) {
				arrayList_string.addAll(vt);
				return arrayList_string;
			}
		}.retVt(Vt));

		for (int k = 0; k < LR_G.length; k++) {
			splitProduction(LR_G[k] + "$");
		}

		HashSet<String> lr_Vn = new HashSet<String>();
		lr_Vn.add("S'");	lr_Vn.add("E");		lr_Vn.add("T");
		lr_Vn.add("F");
		HashSet<String> lr_Vt = new HashSet<String>();
		lr_Vt.add("+");		lr_Vt.add("*");		lr_Vt.add("id");
		lr_Vt.add("(");		lr_Vt.add(")");
		String[] lr_vt = {
				"id","+","*","(",")","$"
		};
		String[] lr_vn = {
				"E","T","F"
		};
		HashSet<String> lr_G = new HashSet<String>();
		lr_G.addAll(lr_Vn);
		lr_G.addAll(lr_Vt);

//		for (String s : lr_Vt) {
//			follow(s);
//		}

		Ij = items(lr_G);
		for (int i1 = 0; i1 < Ij.items.size(); i1++) {
			print("I{0}", i1);
			Ij.get(i1).production.forEach(p -> print("%: {0}", p.Production));
		}

		int num1 = 0, num2 = 0;
		for (String s : lr_vt) {
			VtSequence.put(s, num1++);
		}
		for (String s : lr_vn) {
			VnSequence.put(s, num2++);
		}

		Lexical lrlex = new Lexical("id * id + id");
		lrlex.start();

		LR lr = new LR(lrlex.ret());

		print("Syntax analysis completed");

		follow("IMP");
	}
	// ##################################################

	public ItemFamily items(HashSet<String> G) {
		ItemFamily C = new ItemFamily(CLOSURE(new ItemSet(new String[] { "S' -> · E" })));
		while (true) {
			int size0 = C.size();
			for (int i = 0; i < C.items.size(); i++) {
				for (String X : G) {
					if (GOTO(C.get(i), X).onlyhash() != 0) {
						boolean have = false;
						for (ItemSet item : C.items) {
							if (Objects.equals(item.onlyhash(), GOTO(C.get(i), X).onlyhash())) {
								have = true;
							}
						}
						if (!have) {
							C.items.add(GOTO(C.get(i), X));
						}
					}
				}
			}
			int size1 = C.size();
			if (size1 - size0 == 0) {
				break;
			}
		}

		HashSet<Integer> index = new HashSet<>();
		for (int i = 0; i < C.items.size(); i++) {
			if (Objects.equals(C.items.get(i).onlyhash(), 0)) {
				index.add(i);
			}
		}
		for (Integer p : index) {
			int hash = C.items.get(p).onlyhash();
			C.items.remove(p);
			print("Move out: {0} / onlyhash: {1}", p, hash);
		}

		return C;
	}

	public ItemSet GOTO(ItemSet I, String X) {
		ItemSet J = new ItemSet();

		try {
			// A -> α·Xβ

			ItemSet AllSetOfX = I.containsXandPointInLeft(X);
			for (Produce Xi : AllSetOfX.production) {
				String[] XiBodySplit = Xi.Body.split(" ");
				ArrayList<String> tempBody = new ArrayList<String>();

				boolean MoveSuc = false;
				int MoveIndex = 0;

				for (int XiBodySpliti = 0; XiBodySpliti < XiBodySplit.length; XiBodySpliti++) {
					if (Xi.PointLocation == XiBodySpliti) {
						if (XiBodySplit.length - 1 >= 1 && Objects.equals(XiBodySplit[XiBodySpliti + 1], X)) {
							// 进行移位 XiBodySplit[XiBodySpliti] = XiBodySplit[XiBodySpliti + 1]
							tempBody.add(XiBodySplit[XiBodySpliti + 1]);
							MoveIndex = XiBodySpliti;
							MoveSuc = true;
						} else {
							print("我认为不可能出现的错误出现了！！！ In GOTO");
							MoveSuc = false;
						}
					} else if (Objects.equals(XiBodySplit[XiBodySpliti], X)) {
						// X+1 = X
						if (MoveSuc && XiBodySplit.length - 1 >= 0) {
							tempBody.add(XiBodySplit[MoveIndex]);
						} else {
							print("别慌，这也是我认为不可能出现的错误！ In GOTO");
						}
					} else {
						tempBody.add(XiBodySplit[XiBodySpliti]);
					}
				}

				String tempNewXi = Xi.Head + " -> ";
				for (int i = 0; i < tempBody.size(); i++) {
					tempNewXi += (tempBody.get(i) + " ");
				}
				J.add(tempNewXi.trim());
			}
		} catch (NullPointerException ne) {
			// pass
		}
		return CLOSURE(J);
	}

	HashMap<String, Boolean> added = new HashMap<String, Boolean>();
	public ItemSet CLOSURE (ItemSet I) {
		// J = I
		ItemSet J = I;

		int sizeBefore, sizeAfter = 0;

		// repeat
		while (true) {
			sizeBefore = J.size();

			// for ( J 中的每个项 A -> α·Bβ )
			for (int findB = 0; findB < J.production.size(); findB++) {
 				if (J.get(findB).Body.contains("·")) {
					// 证明这是一个可以被归约的非终结符号
					if (J.get(findB).AfterSymbol != null && J.get(findB).MoveIn == true) {
						ItemSet PrdctBset = new ItemSet();
						int finalFindB = findB;
						P.forEach((i, p) -> {
							if (Objects.equals(p.PrdctHead, J.get(finalFindB).AfterSymbol)) {
								if (new Produce(p.Prdct).PointExsit && new Produce(p.Prdct).PointLocation == 0) {
									PrdctBset.add(p.Prdct);
								}
							}
						});
						// for ( G 的每个产生式 B -> γ )
						for (Produce produce : PrdctBset.production) {
							boolean exist = false;
							for (int inquiry = 0; inquiry < added.size(); inquiry++) {
								if (added.containsKey(produce.Production)) {
									exist = true;
									break;
								} else {
									exist = false;
								}
							}
							if (exist) {
								added.put(produce.Production, true);
								continue;
							} else {
								added.put(produce.Production, true);
								J.add(produce);
							}
						}
					}
				}
			}


			// until 在某一轮中没有新的项被加入到 J 中
			sizeAfter = J.size();
			if (sizeAfter - sizeBefore == 0) {
				break;
			}
		}

		return J;
	}

	public Object[] ptoarray() {
		ArrayList<String> tmp = new ArrayList<String>();
		SetP.forEach((i, p) -> {
			tmp.add(p.replace("$", ""));
		});
		return tmp.toArray();
	}

	/**
	 * Initialization G {Vt, Vn, P, S}
	 * */
	void loadG() throws IOException {
		loadVt(); loadVn(); loadS();
	}

	public Hashtable<String, HashSet<String>> selects = new Hashtable<String, HashSet<String>>();

	public HashSet<String> select(String production, boolean isZero) {

		HashSet<String> select = new HashSet<String>();
		String p = production;

		// select(S -> AB) = first(AB) ∪ follow(S)
		// 拆分产生式
		// 左部
		String left = p.split("->")[0].trim();
		String right = p.replace(left+" ->", "").trim();
		// 右部
		String[] right_split = right.split(" ");
		// left: Vn		right_split: p_right[]

		// If ε∈first(A), then select(S -> AB) = first(AB)∪follow(S)
		for (int right_index = 0; right_index < right_split.length; right_index++) {
			HashSet<String> t0 = new HashSet<String>(startCalcFirst(right_split[right_index]));
			if (isExistEpsilon(t0)) {
				select.addAll(t0);
				select.addAll(startCalcFollow(left));
			}
		}

		if (isZero) {
			boolean haves = false;
			if (follows.containsKey(left)) {
				select.addAll(follows.get(left));
			} else {
				super.print(left);
				select.addAll(startCalcFollow(left));
			}
		}

		selects.put(p, new anonymous(){
			public HashSet<String> retSelect() {
				hashSet_string.addAll(select);
				return hashSet_string;
			}
		}.retSelect());

		if (isZero) {
			super.print("select({0}) = first({1}) ∪ follow({2}) = {{3}}", p, right, left, selects.get(p).toString());
		} else {
			super.print("select({0}) = first({1}) = {{2}}", p, right, selects.get(p).toString());
		}

		return select;
	}

	/**
	 * <p>select</p>
	 * */
	public void select(Object ... production) {
		String before_vn = "";
		HashSet<String> select = new HashSet<String>();
		for (Object P : production) {
			String p = P.toString();
			// select(S -> AB) = first(AB) ∪ follow(S)
			// 拆分产生式
			// 左部
			String left = p.split("->")[0].trim();
			String right = p.replace(left+" ->", "").trim();
			// 右部
			String[] right_split = right.split(" ");
			// left: Vn		right_split: p_right[]
			for (int right_index = 0; right_index < right_split.length; right_index++) {
				select.addAll(startCalcFirst(right_split[right_index]));
			}
			if (left.hashCode() != before_vn.hashCode()) {
				boolean haves = false;
				if (follows.containsKey(left)) {
					select.addAll(follows.get(left));
				} else {
					select.addAll(startCalcFollow(left));
				}
			}
			selects.put(p, new anonymous(){
				public HashSet<String> retSelect() {
					hashSet_string.addAll(select);
					return hashSet_string;
				}
			}.retSelect());
			if (left.hashCode() != before_vn.hashCode()) {
				before_vn = left;
				super.print("select({0}) = first({1}) ∪ follow({2}) = {{3}}", p, right, left, selects.get(p).toString());
			} else {
				super.print("select({0}) = first({1}) = {{2}}", p, right, selects.get(p).toString());
			}
			select.clear();
		}
	}

	/**
	 * <p>first</p>
	 * */
	public void first(String s) {
		getfirst.clear();
		if (super.isVt(s)) {
			firsts.put(s, new anonymous(){
				public HashSet<String> retFirst(){
					hashSet_string.add(s);
					return hashSet_string;
				}
			}.retFirst());
			super.print("first({0}) = {{1}}", s, firsts.get(s).toString());
			return;
		}
		firsts.put(s, startCalcFirst(s));
		super.print("first({0}) = {{1}}", s, firsts.get(s).toString());
	}

	/**
	 * <p>Set size calculated by calcFirst each time</p>
	 * */
	public int calcFirstSize = 0;

	/**
	 * <p>The main algorithm for calculating the first set</p>
	 * */
	public HashSet<String> startCalcFirst(String s) {
		getfirst.clear();
		if (super.isVt(s)) {
			firsts.put(s, new anonymous(){
				public HashSet<String> retFirst(){
					hashSet_string.add(s);
					return hashSet_string;
				}
			}.retFirst());
			return firsts.get(s);
		}
		int first_size = 0;
		int newsize = 0;
		HashSet<String> f = new HashSet<String>();

		while (newsize != first_size || (first_size == 0 && newsize == 0)) {
			if (super.existHashcodeOfVn(s.hashCode())) {
				for (int production_index = 0; production_index < productionMap.get(s).size; production_index++) {

					String production_crt = productionMap.get(s).list.get(production_index);
					String[] production_crt_split = production_crt.split(" ");

					if (super.isVt(production_crt_split[0])) {
						// Is a vt
						f.add(production_crt_split[0]);
						newsize++;
						continue;
					} else {
						// Is a Vn
						f.addAll(startCalcFirst(production_crt_split[0]));
					}
				}
			} else {
				f.addAll(f);
				break;
			}
			newsize = first_size = f.size();
		}
		calcFirstSize = f.size();
		return f;
	}

	/**
	 * <p>follow</p>
	 * */
	public void follow(String vn) {
		if (vn.hashCode() == this.S.hashCode()) {
			super.print("[{0}] It is temporarily not allowed to calculate the follow set of the start symbol", vn, "argX:red");
			return;
		}
		try {
			follows.put(vn, startCalcFollow(vn));
			super.print("follow({0}) = {{1}}", vn, follows.get(vn).toString());
		} catch (NullPointerException ne) {
			// pass
		}
	}

	/**
	 * <p>Set size calculated by calcFollow each time</p>
	 * */
	public int calcFollowSize = 0;
	/**
	 * <p>follow calculate</p>
	 * */
	public HashSet<String> startCalcFollow(String vn) {
		int size = 0;
		int newsize = 0;

		if (vn.hashCode() == this.S.hashCode()) {
//			super.print("[{0}] It is temporarily not allowed to calculate the follow set of the start symbol", vn, "argX:red");
			size = newsize = -1;
		}
		HashSet<String> follow_root = new HashSet<String>();
		boolean isExist = false;

		if (Objects.equals(vn, this.S)) {
			follow_root.add("$");
		}
		while (newsize != size || (newsize == 0 && size == 0)) {
			for (String vn_crt : Vn) {
				for (int vn_crt_production_index = 0; vn_crt_production_index < productionMap.get(vn_crt).size; vn_crt_production_index++) {
					String production_crt = productionMap.get(vn_crt).list.get(vn_crt_production_index);
					String[] production_crt_split = production_crt.split(" ");
					boolean next = false;
					for (int split_index = 0; split_index < production_crt_split.length; split_index++) {
						if (next) {
							next = false;
							if (split_index+1 == production_crt_split.length) {
								break;
							} else {
								continue;
							}
						}

						if (production_crt_split[split_index].equals(vn)) {
							isExist = true;
							// If is equal to vn
							if (split_index+1 == production_crt_split.length) {
								if (follows.containsKey(vn_crt)) {
									follow_root.addAll(follows.get(vn_crt));
								} else {
									if (!followMemoryIsExist((vn+"∪"+vn_crt).hashCode())) {
										if (vn.hashCode() != this.S.hashCode() && vn_crt.hashCode() != this.S.hashCode()) {
											followMemory.put(followMemory.size(), vn+"∪"+vn_crt);
										}
									}
								}
								// 最右符号
								follow_root.add("$");
							} else if (split_index+2 == production_crt_split.length	&& super.isVn(production_crt_split[split_index+1])) {
								// 后随符号是非终结符号，并且是最右符号
								follow_root.addAll(startCalcFirst(production_crt_split[split_index+1]));

								if (isExistEpsilon(startCalcFirst(production_crt_split[split_index+1]))) {
									if (follows.containsKey(vn_crt)) {
										follow_root.addAll(follows.get(vn_crt));
									} else {
										follow_root.addAll(startCalcFollow(vn_crt));
									}
								}
								next = true;
								break;
							} else if (super.isVt(production_crt_split[split_index+1])) {
								// Vt
								follow_root.add(production_crt_split[split_index+1]);
								newsize++;
								next = true;
							} else {
								// FOLLOW(C)   A -> BCD
								follow_root.addAll(startCalcFirst(production_crt_split[split_index+1]));
								if (isExistEpsilon(startCalcFirst(production_crt_split[split_index+1]))) {
									if (follows.containsKey(production_crt_split[split_index+1])) {
										follow_root.addAll(follows.get(production_crt_split[split_index+1]));
									} else {
										follow_root.addAll(startCalcFollow(production_crt_split[split_index+1]));
									}
									if (follows.containsKey(vn_crt)) {
										follow_root.addAll(follows.get(vn_crt));
									} else {
										follow_root.addAll(startCalcFollow(vn_crt));
									}
								}
								next = true;
							}
						}
					}

				}
			}
			if (!isExist) {
				super.print("Cannot find [{0}] on the right side of any production when calculating the follow({0}) set", vn, "argX:err");
				super.print("Some suggestions: use it[{0}] when building CFG", vn, "argX:red");
				break;
			}
			newsize = size = follow_root.size();
		}
		calcFollowSize = follow_root.size();
		return follow_root = discard(follow_root, "-epsilon");
	}

	/**
	 * <p>follow memory</p>
	 * <p>Deprecated code {@code follow.addAll(follow(spi));}
	 * */
	public Hashtable<Integer, String> followMemory = new Hashtable<>();

	/**
	 * <p>Calculate the followMemory set and optimize all follow sets</p>
	 * */
	public void optimizeFollow() {
		followMemory.forEach((i, m) -> {
			String[] m_split = m.split("∪");
			follows.put(m_split[0], new anonymous() {
				public HashSet<String> updateFollow(String m0, String m1) {
					hashSet_string.addAll(follows.get(m0));
					hashSet_string.addAll(follows.get(m1));
					return hashSet_string;
				}
			}.updateFollow(m_split[0], m_split[1]));
		});
		followMemory.clear();
	}

	/**
	 * <p>Check whether there is a value of @params:hashCodeOfValue in the followMemory set</p>
	 * */
	public boolean followMemoryIsExist(int hashCodeOfValue) {
		for (int i = 0; i < followMemory.size(); i++) {
			if (followMemory.get(i).hashCode() == hashCodeOfValue) {
				return true;
			}
		}
		return false;
	}

	public boolean isExistEpsilon(HashSet<String> f) {
		for (String e : f) {
			if (Objects.equals(e.hashCode(), "ε".hashCode())) {
				return true;
			}
		}
		return false;
	}

	/**
	 * <p>Discard nulls and spaces by default</p>
	 * */
	public <T> T discard(T t, Object ... args) {
		boolean defaultType = false;
		for (Object arg : args) {
			if (arg instanceof Class) {
				defaultType = true;
			} else if (arg.toString().equals("-epsilon")) {
				if (t instanceof HashSet) {
					HashSet<String> set = (HashSet<String>) t;
					HashSet<String> tmp = new HashSet<String>();
					for (String e : set) {
						if (Objects.equals(e.hashCode(), "ε".hashCode())) {
							continue;
						}
						tmp.add(e);
					}
					return (T) tmp;
				}
			}
		}
		if (defaultType) {
			String s = t.toString().replace(" ", "");
			s = s.replace("null", "");
			return (T) s;
		}
		return t;
	}
	
	void loadVt() {
		vt_Add(new String[] { "+", "-", "*", "/", "^", "!", "%", "&", "|", "=", "#",
				":", ";", ",", ".", "+=", "-=", "*=", "/=", "^=", "==", "<=", ">=",
				"&&", "||", "++", "--", "->", "!=", "::", "<", ">", "(", ")", "[", "]", "{", "}",
				"if", "else", "switch", "while", "do", "for", "try", "catch",
				"finally", "return", "epsilon", "empty", "#", "import", "class",
				"type", "void", "typedef", "auto", "string", "char", "long",
				"bool", "int", "Integer", "double", "float", "public", "private",
				"protected", "lambda", "λ", "single", "final", "static", "extern",
				"as"
				,"id"
				});
	}
	void vt_Add(String[] VTs) {
		Vt.addAll(Arrays.asList(VTs));
	}
	
	void loadVn() {
		Vn.add("S");			Vn.add("ID");		Vn.add("CLS");
		Vn.add("CLSMODIFIER");	Vn.add("ACTYPE");	Vn.add("BLOCKS");
		Vn.add("BLOCK");		Vn.add("EXPRS");	Vn.add("EXPR");
		Vn.add("FOR_COM");		Vn.add("STMTS");	Vn.add("STMT");
		Vn.add("TYPE");			Vn.add("VALUE");	Vn.add("BOOL");
//		Vn.add("DIGITS");
		Vn.add("DIGIT");		Vn.add("CANUSE_OP");Vn.add("MASGVAL");
		Vn.add("M");			Vn.add("M'");		Vn.add("N");
		Vn.add("OP");			Vn.add("OP'");		Vn.add("LAMBDAS");
		Vn.add("ARGS");			Vn.add("PRE");		Vn.add("IMP");

		// Test
		Vn.add("E");	Vn.add("S'");
		Vn.add("T");
		Vn.add("F");
	}
	void p_Add() throws IOException {
//		Path grammar = Paths.get(System.getProperty("user.dir")+"\\syntax\\apollo.g");
//		ArrayList<String> g = new ArrayList<String>();
//		g = (ArrayList<String>) Files.readAllLines(grammar);
//		for (int i = 0; i < g.size(); i++) {
//			this.SetP.put(i, g.get(i));
//		}
	}
	
	int p_Vn = 0;
	/**
	 * <p>Split production
	 * @param x Production
	 * */
	void splitProduction(String x) {
		String cache = "";	String left = "";	int beput = 0;
		for (int i = 0; i < x.length(); i++) {
			char c = x.charAt(i);
			switch (c) {
			case ' ':
				if (beput != 0) {
					cache += c;
				} else if (beput == 0) {
					left = cache; cache = ""; beput++;
				}
				break;
			case '$':
				super.print("Produce: {0}\t->\t{1}", left, cache.replace("->", "").replace("=>", "->").trim());
				P.put(p_Vn++, new Production(left, cache.replace("->", "").replace("=>", "->").trim()));
				left = cache = "";
				break;
			default:
				cache += c;
				break;
			}
		}
	}
	
	void loadS() {
		this.S = "S";
	}
}
